// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc308.FRC2016.subsystems;

import org.usfirst.frc308.FRC2016.Robot;
import org.usfirst.frc308.FRC2016.RobotConstants;
import org.usfirst.frc308.FRC2016.RobotMap;
import org.usfirst.frc308.FRC2016.commands.*;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class Chasis extends PIDSubsystem {

	boolean turning = true;

	// PID Stuff
	double IAccumulator = 0.0; // the sum of error over time
	double lastError = 0.0; // the previous error
	double error = 0;
	Timer setPointTimer = new Timer();

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	// I'm in
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon left1 = RobotMap.chasisleft1;
	private final CANTalon left2 = RobotMap.chasisleft2;
	private final CANTalon left3 = RobotMap.chasisleft3;
	private final CANTalon right1 = RobotMap.chasisright1;
	private final CANTalon right2 = RobotMap.chasisright2;
	private final CANTalon right3 = RobotMap.chasisright3;
	private final AnalogGyro gyro = RobotMap.chasisgyro;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final Solenoid shifter = RobotMap.pneumaticsshifter;

	BuiltInAccelerometer accel;
	
	public Chasis() {
		super("Drivetrain", RobotConstants.Kp, 0, RobotConstants.Kd);
		setAbsoluteTolerance(RobotConstants.gyroPIDErrorTolerance);
		getPIDController().setContinuous(true);
		getPIDController().setInputRange(-180, 180);
		LiveWindow.addActuator("Drivetrain", "PIDSubsystem Controller", getPIDController());
		getPIDController().setOutputRange(-1.0, 1.0);
		accel = new BuiltInAccelerometer();
		gyro.initGyro();
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new teleopDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void calibrateGyro() {
		// gyro.calibrate();
	}

	public void setupBasicDrive() {
		left1.changeControlMode(TalonControlMode.PercentVbus);
		left2.changeControlMode(TalonControlMode.Follower);
		left2.set(4);
		left3.changeControlMode(TalonControlMode.Follower);
		left3.set(4);
		right1.changeControlMode(TalonControlMode.PercentVbus);
		right2.changeControlMode(TalonControlMode.Follower);
		right2.set(1);
		right3.changeControlMode(TalonControlMode.Follower);
		right3.set(1);

		right1.reverseOutput(false);
		SmartDashboard.putBoolean("rightreversed", true);
		right2.reverseOutput(false);
		right3.reverseOutput(false);
		left1.reverseOutput(false);
		left2.reverseOutput(false);
		left3.reverseOutput(false);

		gyro.reset();
		getPIDController().setSetpoint(0); // make setpoint
															// current angle
		IAccumulator = 0; // reset accumulator
	}
	
	public void setupAdvancedRotate(){
		getPIDController().setPID(RobotConstants.Kp2, 0, RobotConstants.Kd2);
	}

	public void shiftUp() {
		// Matteo
		// set shifter to up
		Robot.chasis.shifter.set(true);
	}

	public void shiftDown() {
		// Matthew
		// set shifter to down
		Robot.chasis.shifter.set(false);
	}

	/**
	 * sets up the PID for rotate command
	 */
	public void setRotatePID(double angleSetPoint) {
		gyro.reset(); // reset gyro so our angle is 0
		getPIDController().setSetpoint(angleSetPoint);
		IAccumulator = 0; // reset accumulator

	}

	public boolean isOnTarget() {
		// if our error is within tolerance and our rotation speed is within our
		// tolerance
		if (Math.abs(getPIDController().getError()) < RobotConstants.gyroPIDErrorTolerance
				&& Math.abs(gyro.getRate()) < RobotConstants.gyroPIDVelocityTolerance) {
			return true;
		}
		return false;
	}

	public void autonomousAdvancedRotate(double time, double p, double t, double ct, double v) {
		if (time < 0.5 * t) {
			double psetpoint = (6.0 * time * time / t / t - 15.0 * time / t + 10.0) * p * time * time * time / t / t
					/ t;
			getPIDController().setSetpoint(psetpoint);
			double vsetpoint = (30.0 * time * time / t / t - 60.0 * time / t + 30.0) * p * time * time / t / t / t;
			double asetpoint = (120.0 * time * time / t / t - 180.0 * time / t + 60.0) * p * time / t / t / t;
			double output = RobotConstants.Kv * vsetpoint + RobotConstants.Ka * asetpoint + RobotConstants.gyroPIDOutput;
			left1.set(output);
			right1.set(output);
		} else if (time < 0.5 * t + ct) {
			double psetpoint = 0.5 * p + (time - 0.5 * t) * v;
			getPIDController().setSetpoint(psetpoint);
			double vsetpoint = v;
			double asetpoint = 0;
			double output = RobotConstants.Kv * vsetpoint + RobotConstants.Ka * asetpoint + RobotConstants.gyroPIDOutput;
			left1.set(-output);
			right1.set(-output);
		} else if (time < t + ct) {
			time -= ct;
			double psetpoint = ct * v
					+ (6.0 * time * time / t / t - 15.0 * time / t + 10.0) * p * time * time * time / t / t / t;
			getPIDController().setSetpoint(psetpoint);
			double vsetpoint = (30.0 * time * time / t / t - 60.0 * time / t + 30.0) * p * time * time / t / t / t;
			double asetpoint = (120.0 * time * time / t / t - 180.0 * time / t + 60.0) * p * time / t / t / t;
			double output = RobotConstants.Kv * vsetpoint + RobotConstants.Ka * asetpoint + RobotConstants.gyroPIDOutput;
			left1.set(output);
			right1.set(output);
		} else {
			left1.set(0);
			right1.set(0);
		}
	}

	public void autonomousRotate() {
		double turn = RobotConstants.gyroPIDOutput;
		left1.set(turn);
		right1.set(turn);
	}

	public double deadZone(double input) {
		if (Math.abs(input) < RobotConstants.deadZone) {
			return 0.0;
		}
		return input;
	}
	
	public void setGyroPIDConstants(){
		getPIDController().setPID(RobotConstants.Kp, 0, RobotConstants.Kd);
	}

	public void basicDrive(double power, double turn) {
		if (left1.getEncVelocity() == 0 && right1.getEncVelocity() == 0
				&& Robot.oi.joystick2.getRawButton(RobotConstants.shootBallHigh)) {
			gyro.reset();
			getPIDController().setSetpoint(0);
		}
		if (turn == 0.0) { // driver isn't turning, keep the last angle
			if (turning == true) { // first time/initialize
				setPointTimer.start();
				RobotConstants.gyroPIDOutput = 0.0;
				turning = false; // we are no longer turning
			} else if (setPointTimer.get() != 0) {
				if (setPointTimer.get() >= 1.0) {
					enablePID();
					getPIDController().setSetpoint(gyro.getAngle());
					setPointTimer.stop();
					setPointTimer.reset();
				}
			} else { // after initializing
				turn = RobotConstants.gyroPIDOutput;
			}
		} else if (turn != 0.0) { // a turn is being commanded
			disablePID();
			setPointTimer.stop();
			setPointTimer.reset();
			turning = true;
		}
		left1.set((power + turn) / 2.0);
		right1.set(-(power - turn) / 2.0);
	}

	@Override
	protected double returnPIDInput() {
		error = getPIDController().getSetpoint() - gyro.getAngle();
		if (error < -180.0) {
			while (error < -180.0) {
				error += 360.0;
			}
		} else if (error > 180.0) {
			while (error > 180.0) {
				error -= 360.0;
			}
		}
		if (Math.abs(error) < RobotConstants.iZone && error * lastError > 0) {
			IAccumulator += error;
			if (RobotConstants.Kp * error + RobotConstants.Ki * IAccumulator > RobotConstants.maximumIZoneSpeed) {
				IAccumulator = (RobotConstants.maximumIZoneSpeed - RobotConstants.Kp * error) / RobotConstants.Ki;
			} else if (RobotConstants.Kp * error
					+ RobotConstants.Ki * IAccumulator < -RobotConstants.maximumIZoneSpeed) {
				IAccumulator = (-RobotConstants.maximumIZoneSpeed - RobotConstants.Kp * error) / RobotConstants.Ki;
			}
		} else {
			IAccumulator = 0;
		}
		lastError = error;
		return gyro.getAngle();
	}

	@Override
	protected void usePIDOutput(double output) {
		RobotConstants.gyroPIDOutput = output + RobotConstants.Ki * IAccumulator;
	}

	public void disablePID() {
		if (getPIDController().isEnabled()) {
			IAccumulator = 0;
			getPIDController().reset(); // disables and resets integral
		}
	}

	public void enablePID() {
		if (!getPIDController().isEnabled()) {
			gyro.reset();
			IAccumulator = 0;
			getPIDController().enable();
			setSetpoint(0.0);
		}
	}

	public void resetEncoders() {
		left1.setEncPosition(0);
	}

	public double getEncoderPosition() {
		return left1.getEncPosition();
	}

	public void displayChasisData() {
		SmartDashboard.putNumber("accel x",accel.getX());
		SmartDashboard.putNumber("accel y",accel.getY());
		SmartDashboard.putNumber("accel z",accel.getZ());
		SmartDashboard.putNumber("robot position", left1.getEncPosition());
		SmartDashboard.putNumber("angle", gyro.getAngle());
		SmartDashboard.putNumber("rotation speed", gyro.getRate());
		SmartDashboard.putNumber("gyro error", error);
	}

	public void setupNormalRotate() {
		getPIDController().setPID(RobotConstants.Kp, 0, RobotConstants.Kd);
	}

}
